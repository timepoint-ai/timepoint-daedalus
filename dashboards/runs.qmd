---
title: "Run Selection"
format:
  html:
    page-layout: full
    code-tools: false
---

```{ojs}
//| echo: false

// API configuration
API_BASE = "http://localhost:8000"

// Test API connection
apiStatus = {
  try {
    const response = await fetch(`${API_BASE}/`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    console.log('API Status:', data);
    return data.status === 'ok';
  } catch (error) {
    console.error('API connection failed:', error);
    return false;
  }
}

// Fetch templates for filter dropdown
templates = {
  if (!apiStatus) {
    console.error('API not available');
    return [];
  }
  try {
    const response = await fetch(`${API_BASE}/api/templates`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    return data.templates;
  } catch (error) {
    console.error('Failed to fetch templates:', error);
    return [];
  }
}
```

```{ojs}
//| echo: false

apiStatusMessage = apiStatus
  ? html``
  : html`<div class="alert alert-danger" role="alert">
      <strong>⚠️ API Connection Failed</strong><br/>
      Cannot connect to backend API at ${API_BASE}.<br/>
      Please ensure the API server is running: <code>cd dashboards && ./backend.sh</code>
    </div>`
```

::: {.grid}

::: {.g-col-3}
### Filters

```{ojs}
//| echo: false

viewof templateFilter = Inputs.select(
  ["All"].concat(templates || []),
  {label: "Template", value: "All"}
)

viewof statusFilter = Inputs.select(
  ["All", "completed", "running", "failed"],
  {label: "Status", value: "All"}
)

viewof causalModeFilter = Inputs.select(
  ["All", "STANDARD", "PORTAL"],
  {label: "Causal Mode", value: "All"}
)
```

---

```{ojs}
//| echo: false

viewof dateFromFilter = Inputs.date({
  label: "Date From",
  value: null
})

viewof dateToFilter = Inputs.date({
  label: "Date To",
  value: null
})
```

---

```{ojs}
//| echo: false

viewof minCostFilter = Inputs.range(
  [0, 100],
  {label: "Min Cost ($)", step: 0.1, value: 0}
)

viewof maxCostFilter = Inputs.range(
  [0, 100],
  {label: "Max Cost ($)", step: 0.1, value: 100}
)
```

---

```{ojs}
//| echo: false

viewof minEntitiesFilter = Inputs.range(
  [0, 100],
  {label: "Min Entities", step: 1, value: 0}
)

viewof minTimepointsFilter = Inputs.range(
  [0, 100],
  {label: "Min Timepoints", step: 1, value: 0}
)
```

---

```{ojs}
//| echo: false

viewof mechanismFilter = Inputs.text({
  label: "Mechanisms (comma-separated, e.g. M1,M5,M17)",
  placeholder: "M1,M5,M17"
})
```

---

```{ojs}
//| echo: false

viewof searchQuery = Inputs.text({
  label: "Search Run ID",
  placeholder: "Search by run ID..."
})

viewof onlyCompleteData = Inputs.checkbox(
  ["Show only runs likely to have visualizations"],
  {label: "Data Filter", value: []}
)

html`<div style="font-size: 0.75rem; color: #6c757d; margin-top: 0.25rem; margin-left: 1.5rem;">
  Filters to completed runs with entities and timepoints in database.<br/>
  <em>Note: Some runs may still lack exported narrative files.</em>
</div>`
```

:::

::: {.g-col-9}

### Runs

```{ojs}
//| echo: false

sortFieldOptions = [
  {label: "Date Started", value: "started_at"},
  {label: "Date Completed", value: "completed_at"},
  {label: "Cost", value: "cost_usd"},
  {label: "Entities", value: "entities_created"},
  {label: "Timepoints", value: "timepoints_created"},
  {label: "Duration", value: "duration_seconds"}
]

viewof sortField = Inputs.select(
  sortFieldOptions.map(d => d.value),
  {
    label: "Sort By",
    value: "started_at",
    format: (value) => sortFieldOptions.find(d => d.value === value)?.label || value
  }
)

viewof sortOrder = Inputs.select(
  ["DESC", "ASC"],
  {label: "Order", value: "DESC"}
)

viewof pageLimit = Inputs.select(
  [10, 25, 50, 100],
  {label: "Per Page", value: 50}
)

viewof currentPage = Inputs.number({
  label: "Page",
  value: 1,
  min: 1,
  step: 1
})
```

```{ojs}
//| echo: false

// Build query parameters
queryParams = {
  const params = new URLSearchParams();

  if (templateFilter !== "All") params.append("template", templateFilter);
  if (statusFilter !== "All") params.append("status", statusFilter);
  if (causalModeFilter !== "All") params.append("causal_mode", causalModeFilter);
  if (dateFromFilter) params.append("date_from", dateFromFilter.toISOString());
  if (dateToFilter) params.append("date_to", dateToFilter.toISOString());
  if (minCostFilter > 0) params.append("min_cost", minCostFilter);
  if (maxCostFilter < 100) params.append("max_cost", maxCostFilter);
  if (minEntitiesFilter > 0) params.append("min_entities", minEntitiesFilter);
  if (minTimepointsFilter > 0) params.append("min_timepoints", minTimepointsFilter);
  if (mechanismFilter) params.append("mechanisms", mechanismFilter);

  params.append("sort_by", sortField);
  params.append("order", sortOrder);
  params.append("page", currentPage);
  params.append("limit", pageLimit);

  return params;
}

// Fetch runs data
runsData = {
  try {
    const response = await fetch(`${API_BASE}/api/runs?${queryParams}`);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Failed to fetch runs:', error);
    return {runs: [], total: 0, pages: 1};
  }
}

// Extract values for display
runs = runsData.runs || []
totalRuns = runsData.total || 0
totalPages = runsData.pages || 1

// Check if run has complete visualization data
// A run needs: completed status, cost (ran), entities & timepoints (has data)
// Timepoints > 2 ensures there's actual timeline data for visualization
hasCompleteData = (run) => {
  return run.status === 'completed' &&
         run.cost_usd > 0 &&
         run.entities_created > 0 &&
         run.timepoints_created > 2  // Need at least 3 timepoints for meaningful visualization
}

// Filter by search query and data completeness (client-side)
filteredRuns = runs.filter(r => {
  // Search filter
  if (searchQuery && !r.run_id.toLowerCase().includes(searchQuery.toLowerCase())) {
    return false
  }

  // Data completeness filter
  if (onlyCompleteData.length > 0 && !hasCompleteData(r)) {
    return false
  }

  return true
})
```

```{ojs}
//| echo: false

completeCount = filteredRuns.filter(r => hasCompleteData(r)).length
incompleteCount = filteredRuns.length - completeCount
```

**Showing ${filteredRuns.length} of ${totalRuns} runs (Page ${currentPage} of ${totalPages})**

<span style="margin-left: 1rem; color: #28a745; font-weight: 600;">✓ ${completeCount} complete</span>
<span style="margin-left: 0.5rem; color: #6c757d;">○ ${incompleteCount} incomplete</span>

```{ojs}
//| echo: false

html`<div class="table-container">
  <table class="runs-table">
    <thead>
      <tr>
        <th>Data</th>
        <th>Run ID</th>
        <th>Template</th>
        <th>Started</th>
        <th>Cost</th>
        <th>Entities</th>
        <th>TPs</th>
        <th>Status</th>
      </tr>
    </thead>
    <tbody>
      ${filteredRuns.length === 0
        ? `<tr><td colspan="8" style="text-align: center; padding: 2rem; color: #6c757d;">No runs found</td></tr>`
        : filteredRuns.map(run => {
          const cost = run.cost_usd ? `$${run.cost_usd.toFixed(2)}` : '$0.00';
          const started = new Date(run.started_at).toLocaleDateString() + ' ' +
                          new Date(run.started_at).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});

          const statusClass = run.status === 'completed' ? 'status-completed'
            : run.status === 'failed' ? 'status-failed'
            : 'status-running';

          const isComplete = hasCompleteData(run);
          const dataIcon = isComplete
            ? '<span class="data-complete" title="Complete visualization data available">✓</span>'
            : '<span class="data-incomplete" title="Incomplete data - may not have visualizations">○</span>';

          return `<tr
            class="run-row"
            onclick="window.location.href='index.html?run_id=${run.run_id}'"
            style="cursor: pointer;"
          >
            <td class="data-cell">${dataIcon}</td>
            <td><code class="run-id">${run.run_id}</code></td>
            <td class="template-cell">${run.template_id}</td>
            <td class="date-cell">${started}</td>
            <td class="cost-cell">${cost}</td>
            <td class="number-cell">${run.entities_created}</td>
            <td class="number-cell">${run.timepoints_created}</td>
            <td><span class="status-badge ${statusClass}">${run.status}</span></td>
          </tr>`;
        }).join('')}
    </tbody>
  </table>
</div>

<style>
  .table-container {
    overflow-x: auto;
    margin-top: 1rem;
    border: 1px solid #dee2e6;
    border-radius: 0.5rem;
    background: white;
  }

  .runs-table {
    width: 100%;
    border-collapse: collapse;
    background: white;
  }

  .runs-table th {
    background: #2c3e50;
    color: #ffffff !important;
    padding: 1rem 0.75rem;
    text-align: left;
    font-weight: 600;
    font-size: 0.875rem;
    text-transform: uppercase;
    letter-spacing: 0.05em;
    position: sticky;
    top: 0;
    z-index: 10;
  }

  .runs-table td {
    padding: 0.75rem;
    border-bottom: 1px solid #dee2e6;
    color: #212529;
    background: white;
    font-size: 0.875rem;
  }

  .run-row:hover td {
    background: #f8f9fa;
  }

  .run-id {
    font-family: 'Courier New', monospace;
    font-size: 0.75rem;
    color: #495057;
    background: #f8f9fa;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    display: inline-block;
    max-width: 200px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }

  .template-cell {
    font-weight: 500;
    color: #2c3e50;
  }

  .date-cell {
    color: #6c757d;
    font-size: 0.8125rem;
    white-space: nowrap;
  }

  .cost-cell {
    font-weight: 600;
    color: #28a745;
  }

  .number-cell {
    text-align: center;
    font-weight: 500;
    color: #495057;
  }

  .data-cell {
    text-align: center;
    width: 50px;
  }

  .data-complete {
    display: inline-block;
    font-size: 1.25rem;
    color: #28a745;
    font-weight: bold;
  }

  .data-incomplete {
    display: inline-block;
    font-size: 1.25rem;
    color: #6c757d;
    opacity: 0.5;
  }

  .status-badge {
    display: inline-block;
    padding: 0.25rem 0.75rem;
    border-radius: 1rem;
    font-weight: 600;
    font-size: 0.75rem;
    text-transform: uppercase;
  }

  .status-completed {
    background: #d4edda;
    color: #155724;
  }

  .status-failed {
    background: #f8d7da;
    color: #721c24;
  }

  .status-running {
    background: #fff3cd;
    color: #856404;
  }

  @media (max-width: 768px) {
    .runs-table th,
    .runs-table td {
      padding: 0.5rem;
      font-size: 0.75rem;
    }

    .run-id {
      max-width: 150px;
    }
  }
</style>
`
```

:::

:::
