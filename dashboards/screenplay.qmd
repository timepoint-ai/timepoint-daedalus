---
title: "Screenplay Viewer"
format:
  html:
    page-layout: full
    code-tools: false
    include-in-header:
      - text: |
          <script src="https://cdn.jsdelivr.net/npm/fountain-js@0.1.10/fountain.min.js"></script>
---

::: {.callout-note}
## Navigation
[← Dashboard](index.html) | [Browse Runs](runs.html)
:::

```{ojs}
//| echo: false

// API configuration
API_BASE = "http://localhost:8000"

// Get run_id from URL parameter
urlParams = new URLSearchParams(window.location.search)
runId = urlParams.get('run_id')

// Fetch screenplay data
screenplayData = runId ? (async () => {
  try {
    const response = await fetch(`${API_BASE}/api/screenplay/${runId}`);
    if (!response.ok) throw new Error('Screenplay not found');
    return await response.text();
  } catch (error) {
    console.error('Error fetching screenplay:', error);
    return null;
  }
})() : null

screenplay = await screenplayData
```

::: {.panel}
${runId ? '' : html`<div class="alert alert-warning">⚠️ No run ID specified. Navigate from a run to view its screenplay.</div>`}
:::

## Screenplay: ${runId || 'Not selected'}

```{ojs}
//| echo: false

// Parse Fountain screenplay
parsed = screenplay ? fountain.parse(screenplay) : null

// Extract scenes
scenes = parsed ? parsed.tokens.filter(t => t.type === 'scene_heading') : []

// Extract characters
characters = parsed ? [...new Set(
  parsed.tokens
    .filter(t => t.type === 'character')
    .map(t => t.text.trim())
)] : []
```

::: {.grid}

::: {.g-col-12 .g-col-md-3}
### Navigation

```{ojs}
//| echo: false

viewof selectedScene = scenes.length > 0 ? Inputs.select(
  ['All Scenes'].concat(scenes.map((s, i) => `Scene ${i + 1}: ${s.text}`)),
  {label: "Jump to Scene", value: "All Scenes"}
) : html`<p class="text-muted">No scenes available</p>`

viewof characterFilter = characters.length > 0 ? Inputs.select(
  ['All Characters'].concat(characters),
  {label: "Filter by Character", value: "All Characters"}
) : html`<p class="text-muted">No characters available</p>`

viewof searchText = Inputs.text({
  label: "Search Dialog",
  placeholder: "Search text..."
})
```

**Statistics:**

```{ojs}
//| echo: false

html`
<div style="background: #f8f9fa; padding: 0.75rem; border-radius: 0.5rem; margin-top: 1rem;">
  <div style="margin-bottom: 0.5rem;">
    <strong>Scenes:</strong> ${scenes.length}
  </div>
  <div style="margin-bottom: 0.5rem;">
    <strong>Characters:</strong> ${characters.length}
  </div>
  <div>
    <strong>Lines:</strong> ${parsed ? parsed.tokens.filter(t => t.type === 'dialogue').length : 0}
  </div>
</div>
`
```

:::

::: {.g-col-12 .g-col-md-9}

```{ojs}
//| echo: false

screenplayView = {
  if (!screenplay) {
    return html`<div class="alert alert-info">No screenplay available for this run.</div>`;
  }

  // Filter tokens based on selections
  let filteredTokens = parsed.tokens;

  // Filter by character
  if (characterFilter !== 'All Characters') {
    let inMatchingScene = false;
    filteredTokens = filteredTokens.filter(token => {
      if (token.type === 'scene_heading') {
        // Check if any dialogue in this scene matches the character
        const sceneIndex = parsed.tokens.indexOf(token);
        const nextSceneIndex = parsed.tokens.findIndex((t, i) =>
          i > sceneIndex && t.type === 'scene_heading'
        );
        const sceneEnd = nextSceneIndex === -1 ? parsed.tokens.length : nextSceneIndex;
        const sceneTokens = parsed.tokens.slice(sceneIndex, sceneEnd);
        inMatchingScene = sceneTokens.some(t =>
          t.type === 'character' && t.text.trim() === characterFilter
        );
        return inMatchingScene;
      }
      if (token.type === 'character' && token.text.trim() === characterFilter) {
        return true;
      }
      if (inMatchingScene && (token.type === 'dialogue' || token.type === 'parenthetical' || token.type === 'action')) {
        return true;
      }
      return false;
    });
  }

  // Filter by scene
  if (selectedScene !== 'All Scenes') {
    const sceneNum = parseInt(selectedScene.match(/Scene (\d+)/)[1]) - 1;
    const sceneToken = scenes[sceneNum];
    const sceneIndex = parsed.tokens.indexOf(sceneToken);
    const nextSceneIndex = parsed.tokens.findIndex((t, i) =>
      i > sceneIndex && t.type === 'scene_heading'
    );
    const sceneEnd = nextSceneIndex === -1 ? parsed.tokens.length : nextSceneIndex;
    filteredTokens = parsed.tokens.slice(sceneIndex, sceneEnd);
  }

  // Filter by search text
  if (searchText) {
    const searchLower = searchText.toLowerCase();
    let inMatchingSection = false;
    let lastMatchIndex = -1;

    filteredTokens = filteredTokens.filter((token, index) => {
      if (token.type === 'scene_heading') {
        inMatchingSection = false;
        return true; // Always show scene headings
      }

      if (token.text && token.text.toLowerCase().includes(searchLower)) {
        inMatchingSection = true;
        lastMatchIndex = index;
        return true;
      }

      // Show context around matches (3 tokens before and after)
      if (inMatchingSection && index <= lastMatchIndex + 3) {
        return true;
      }

      return false;
    });
  }

  // Render screenplay
  const container = html`<div class="screenplay-container"></div>`;

  const renderToken = (token) => {
    switch (token.type) {
      case 'scene_heading':
        return `<h3 class="scene-heading">${token.text}</h3>`;
      case 'action':
        return `<p class="action">${token.text}</p>`;
      case 'character':
        return `<p class="character">${token.text}</p>`;
      case 'dialogue':
        return `<p class="dialogue">${token.text}</p>`;
      case 'parenthetical':
        return `<p class="parenthetical">${token.text}</p>`;
      case 'transition':
        return `<p class="transition">${token.text}</p>`;
      default:
        return `<p>${token.text || ''}</p>`;
    }
  };

  container.innerHTML = `
    <style>
      .screenplay-container {
        font-family: 'Courier New', Courier, monospace;
        max-width: 800px;
        margin: 0 auto;
        padding: 2rem;
        background: white;
        border: 1px solid #dee2e6;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }

      .scene-heading {
        font-weight: bold;
        text-transform: uppercase;
        margin: 2rem 0 1rem 0;
        border-bottom: 2px solid #333;
        padding-bottom: 0.5rem;
      }

      .action {
        margin: 1rem 0;
        line-height: 1.5;
      }

      .character {
        margin: 1.5rem 0 0.25rem 40%;
        font-weight: bold;
      }

      .dialogue {
        margin: 0.25rem 0 0.25rem 25%;
        max-width: 50%;
        line-height: 1.4;
      }

      .parenthetical {
        margin: 0.25rem 0 0.25rem 30%;
        font-style: italic;
      }

      .transition {
        text-align: right;
        font-weight: bold;
        margin: 1.5rem 0;
      }
    </style>
    ${filteredTokens.map(renderToken).join('\n')}
  `;

  return container;
}
```

:::

:::

## Download

```{ojs}
//| echo: false

downloadButton = screenplay ? html`
  <button
    onclick="${() => {
      const blob = new Blob([screenplay], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `screenplay_${runId}.fountain`;
      a.click();
      URL.revokeObjectURL(url);
    }}"
    style="
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 0.5rem;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    "
  >
    ⬇ Download Fountain Script
  </button>
` : ''
```
